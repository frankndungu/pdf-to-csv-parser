# SMM Parser and PostgreSQL Loader

## Overview

This repository provides a parser for the _Standard Method of Measurement (SMM)_ document. It extracts sections, subsections, clauses, and subclauses from the official PDF and outputs them in a structured CSV format that can be loaded directly into PostgreSQL.

The goal is to preserve the full hierarchy of the SMM:

- Section (A, B, C…)
- Subsections within each section
- Clauses (e.g., A1, B3)
- Subclauses (e.g., A2(a), F12(b))

The parser also includes cleaning and normalization steps to ensure clause text is consistent and free of common PDF artifacts.

---

## Files

### `parse_smm.py`

The main parser script. Responsibilities:

- Opens and reads `SMM.pdf` using `pdfplumber`.
- Identifies sections, subsections, clauses, and subclauses using regular expressions.
- Normalizes and cleans text:
  - Fixes hyphenation across line breaks.
  - Removes multiple or non-breaking spaces.
  - Collapses multi-line text into single lines.
- Generates unique IDs for all rows, including synthetic IDs for section headers and subsections.
- Preserves order within each section with `order_in_section`.
- Writes results to `smm_clean.csv`.
- Validates coverage by comparing clause IDs found in the PDF with those written to CSV.

### `smm_structure.py`

Defines the expected section and subsection structure for the SMM. This ensures that all subsections appear in the CSV output, even if inconsistencies exist in the PDF text.

Example:

```python
SMM_STRUCTURE = {
    "A": ["General Rules"],
    "B": [
        "Preliminaries",
        "Preliminary particulars",
        "Contracts particulars",
        ...
    ],
    ...
}
```

### `SMM.pdf`

The source document to be parsed.

### `smm_clean.csv`

The CSV output generated by the parser. This file is structured for direct ingestion into PostgreSQL.

---

## CSV Output Schema

The CSV has the following fields:

| Column             | Description                                                                                                                                    |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`               | Unique identifier. Clauses use natural IDs (A1, A2(a)), section headers use synthetic IDs (A_HEADER), subsections use synthetic IDs (B_SUB_2). |
| `section_code`     | Section letter (A–Z).                                                                                                                          |
| `section_ref`      | Human-readable name of the section (e.g. "General Rules", "Preliminaries").                                                                    |
| `subsection_title` | Title of the subsection, from `smm_structure.py` or parsed text.                                                                               |
| `clause_ref`       | Clause reference (e.g., A2).                                                                                                                   |
| `subclause_ref`    | Subclause reference (e.g., A2(a)).                                                                                                             |
| `clause_title`     | Title parsed from the clause text (heuristic).                                                                                                 |
| `clause_text`      | Cleaned text of the clause or subclause.                                                                                                       |
| `clause_type`      | Type of row: `section_header`, `subsection`, `clause`, or `subclause`.                                                                         |
| `order_in_section` | Sequential order of the row within its section, useful for preserving hierarchy.                                                               |

---

## PostgreSQL Schema

Run the following to create the table in PostgreSQL:

```sql
CREATE TABLE smm_clauses (
    uid SERIAL PRIMARY KEY,
    id VARCHAR(50),
    section_code CHAR(1) NOT NULL,
    section_ref TEXT NOT NULL,
    subsection_title TEXT,
    clause_ref VARCHAR(50),
    subclause_ref VARCHAR(50),
    clause_title TEXT,
    clause_text TEXT,
    clause_type VARCHAR(20) NOT NULL,
    order_in_section INT NOT NULL
);
```

### Recommended Indexes

```sql
-- Unique clause identifiers
CREATE UNIQUE INDEX idx_smm_clauses_id ON smm_clauses(id);

-- Section-level filtering
CREATE INDEX idx_smm_clauses_section ON smm_clauses(section_code);

-- Full-text search on text
CREATE INDEX idx_smm_clauses_textsearch
ON smm_clauses USING GIN (to_tsvector('english', clause_text));
```

---

## Importing Data

Use `\copy` in `psql` to import the generated CSV:

```sql
\copy smm_clauses(id, section_code, section_ref, subsection_title, clause_ref, subclause_ref, clause_title, clause_text, clause_type, order_in_section)
FROM '/path/to/smm_clean.csv'
DELIMITER ','
CSV HEADER;
```

---

## Query Examples

**1. List all clauses in Section B (Preliminaries):**

```sql
SELECT id, clause_text
FROM smm_clauses
WHERE section_code = 'B'
ORDER BY order_in_section;
```

**2. Find all subclauses under clause A2:**

```sql
SELECT id, clause_text
FROM smm_clauses
WHERE clause_ref = 'A2'
ORDER BY order_in_section;
```

**3. Search for any clause mentioning "foundation":**

```sql
SELECT id, clause_text
FROM smm_clauses
WHERE to_tsvector('english', clause_text) @@ plainto_tsquery('foundation');
```

**4. Rebuild hierarchy of Section D:**

```sql
SELECT id, clause_type, clause_title, clause_text
FROM smm_clauses
WHERE section_code = 'D'
ORDER BY order_in_section;
```

---

## Validation and Logging

When you run `parse_smm_pgsql.py`, it outputs summary information:

- Number of rows written to CSV.
- Number of unique clauses detected in PDF.
- Number of unique clauses written to CSV.
- Any missing IDs (clauses detected in the PDF but not in the CSV).
- Any extra IDs (synthetic IDs added).

This helps ensure that parsing is complete and consistent.

---

## Future Improvements

- Enhance title/body splitting heuristics for more accurate `clause_title` detection.
- Add parent-child relationship fields (`parent_id`) for easier hierarchical joins.
- Extend full-text indexing to include `clause_title`.
- Package as a CLI tool for wider use.
